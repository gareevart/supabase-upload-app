# Сохранение фильтров блога в URL

## Проблема
При переходе на страницу черновика из блога и возврате обратно, выбранный фильтр (например, "Черновики") сбрасывался на значение по умолчанию.

## Решение
Реализовано сохранение состояния фильтра и вида отображения в URL параметрах.

### Изменения в `/app/blog/page.tsx`

1. **Добавлен useSearchParams** для чтения URL параметров
2. **Синхронизация с URL**: Состояние фильтра и вида теперь читается из URL при загрузке страницы
3. **Функция updateURLParams**: Обновляет URL при изменении фильтра или вида без перезагрузки страницы

### URL параметры

- `filter` - тип фильтра (`all`, `published`, `drafts`)
- `view` - режим отображения (`list` для списка, отсутствует для сетки)

### Примеры URL

- `/blog` - все статьи, вид сетки (по умолчанию)
- `/blog?filter=drafts` - черновики, вид сетки
- `/blog?filter=published&view=list` - опубликованные, вид списка
- `/blog?filter=drafts&view=list` - черновики, вид списка

## Преимущества

1. ✅ Состояние фильтра сохраняется при навигации
2. ✅ Можно делиться ссылкой с определённым фильтром
3. ✅ Работает кнопка "Назад" в браузере
4. ✅ История браузера корректно отслеживает изменения фильтров
5. ✅ Опция `scroll: false` предотвращает прокрутку страницы при изменении фильтра

## Технические детали

- Используется `router.push()` с опцией `{ scroll: false }` для обновления URL без прокрутки
- `useEffect` синхронизирует локальное состояние с URL параметрами
- Валидация параметров предотвращает установку некорректных значений

## Исправление лоадера

### Проблема
При переключении фильтров показывался странный лоадер с эффектом размытия (backdrop-blur) поверх карточек, что создавало плохой UX.

### Решение
1. **Удален искусственный лоадер** - убран компонент `Spin` с backdrop-blur-sm
2. **Удален искусственный delay** - убрана задержка в 300ms через setTimeout
3. **Используется встроенный Skeleton** - компонент `PostList` уже имеет красивый встроенный `Skeleton` лоадер для состояния загрузки данных

Теперь при переключении фильтров пользователь видит естественный переход с использованием встроенного `Skeleton` компонента, что обеспечивает лучший UX.

